<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RETRO PIXEL LAB v3.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        /* --- THEME CONSTANTS --- */
        :root {
            --bg-teal: #008080;
            --win-gray: #c0c0c0;
            --win-light: #ffffff;
            --win-dark: #808080;
            --win-black: #000000;
            --win-blue: #000080;
            --font-main: 'VT323', monospace;
        }

        /* --- GLOBAL LAYOUT --- */
        body {
            background-color: var(--bg-teal);
            font-family: var(--font-main);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        /* --- RETRO UI KIT --- */
        .bevel-up {
            border-top: 2px solid var(--win-light);
            border-left: 2px solid var(--win-light);
            border-right: 2px solid var(--win-black);
            border-bottom: 2px solid var(--win-black);
            background: var(--win-gray);
        }

        .bevel-down {
            border-top: 2px solid var(--win-dark);
            border-left: 2px solid var(--win-dark);
            border-right: 2px solid var(--win-light);
            border-bottom: 2px solid var(--win-light);
            background: #fff;
        }

        .bevel-btn {
            cursor: pointer;
            border-top: 2px solid var(--win-light);
            border-left: 2px solid var(--win-light);
            border-right: 2px solid var(--win-black);
            border-bottom: 2px solid var(--win-black);
            background: var(--win-gray);
            transition: transform 0.05s;
        }
        .bevel-btn:active {
            border-top: 2px solid var(--win-black);
            border-left: 2px solid var(--win-black);
            border-right: 2px solid var(--win-light);
            border-bottom: 2px solid var(--win-light);
            transform: translate(1px, 1px);
        }

        /* Windows 3.1 Checkbox Style */
        .w31-checkbox {
            appearance: none;
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: white;
            border-top: 2px solid var(--win-dark);
            border-left: 2px solid var(--win-dark);
            border-bottom: 2px solid var(--win-light);
            border-right: 2px solid var(--win-light);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin-right: 4px;
            position: relative;
        }
        .w31-checkbox:checked::after {
            content: 'x';
            font-family: sans-serif;
            font-size: 14px;
            line-height: 10px;
            color: black;
            font-weight: bold;
            position: absolute;
            top: -1px;
            left: 1px;
        }

        /* Windows 3.1 Number Input Style */
        .w31-num {
            font-family: var(--font-main);
            border-top: 2px solid var(--win-dark);
            border-left: 2px solid var(--win-dark);
            border-right: 2px solid var(--win-light);
            border-bottom: 2px solid var(--win-light);
            background: #fff;
            padding: 0 2px;
            text-align: right;
            width: 48px;
            height: 24px;
            font-size: 1.1rem;
        }
        .w31-num:focus { outline: none; background: #eee; }

        /* --- COMPONENT STYLES --- */
        .main-window {
            width: 98vw;
            height: 96vh;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            box-shadow: 8px 8px 0px rgba(0,0,0,0.5);
            z-index: 10;
            border: 1px solid var(--win-light);
            outline: 1px solid var(--win-black);
        }

        .title-bar {
            background: var(--win-blue);
            color: white;
            padding: 2px 8px;
            font-size: 1.3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            letter-spacing: 1px;
            font-weight: bold;
        }

        /* --- MENU BAR --- */
        .menu-bar {
            display: flex;
            background: var(--win-gray);
            border-bottom: 1px solid var(--win-black);
            padding-left: 2px;
        }

        .menu-item {
            padding: 2px 8px;
            cursor: pointer;
            position: relative;
            font-size: 1.2rem;
        }
        
        .menu-item:hover {
            background: var(--win-blue);
            color: white;
        }

        .dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--win-gray);
            border: 2px solid var(--win-light);
            border-right-color: var(--win-black);
            border-bottom-color: var(--win-black);
            min-width: 180px;
            display: none;
            flex-direction: column;
            z-index: 1000;
            color: black;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.2);
        }

        .dropdown.show { display: flex; }

        .dropdown-item {
            padding: 4px 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
        }

        .dropdown-item:hover {
            background: var(--win-blue);
            color: white;
        }
        
        .dropdown-separator {
            height: 1px;
            background: var(--win-dark);
            margin: 2px;
            border-bottom: 1px solid var(--win-light);
        }

        .app-body {
            flex: 1;
            display: flex;
            overflow: hidden;
            padding: 4px;
            gap: 4px;
        }

        .sidebar {
            width: 280px;
            min-width: 280px;
            overflow-y: auto;
            padding-right: 4px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .group-box {
            border: 1px solid var(--win-dark);
            padding: 8px;
            position: relative;
            margin-top: 8px;
            box-shadow: -1px -1px 0 var(--win-light), 1px 1px 0 var(--win-white);
        }
        
        .group-label {
            position: absolute;
            top: -10px;
            left: 8px;
            background: var(--win-gray);
            padding: 0 4px;
            color: #000;
        }

        /* Form Inputs */
        input[type="range"] {
            flex: 1;
            height: 20px;
            -webkit-appearance: none;
            background: transparent;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: var(--win-black);
            border-right: 1px solid white;
            border-bottom: 1px solid white;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 10px;
            background: var(--win-gray);
            border: 2px solid;
            border-color: white black black white;
            margin-top: -8px;
            cursor: pointer;
        }

        select {
            font-family: var(--font-main);
            border: 2px solid var(--win-dark);
            border-right-color: white;
            border-bottom-color: white;
            background: #fff;
            box-shadow: inset 2px 2px 0 #000;
        }

        /* Canvas & Viewport */
        .viewport-container {
            flex: 1;
            position: relative;
            background: #2a2a2a;
            overflow: hidden;
            border: 2px solid var(--win-dark);
            border-color: var(--win-dark) white white var(--win-dark);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
        }
        .viewport-container:active { cursor: grabbing; }

        .checker-bg {
            background-image: 
                linear-gradient(45deg, #333 25%, transparent 25%), 
                linear-gradient(-45deg, #333 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #333 75%), 
                linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        canvas {
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transform-origin: center;
        }

        .overlay-msg {
            position: absolute;
            inset: 0;
            background: rgba(0,0,128, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            font-size: 2rem;
            text-shadow: 2px 2px #000;
            backdrop-filter: blur(2px);
        }

        /* Responsive */
        @media (max-width: 800px) {
            .app-body { flex-direction: column-reverse; }
            .sidebar { width: 100%; height: 250px; flex: none; border-top: 2px solid black;}
        }

        /* --- NEW UI ELEMENTS --- */
        .tool-btn.active {
            background: var(--win-blue);
            color: white !important;
            border-top: 2px solid var(--win-black);
            border-left: 2px solid var(--win-black);
            border-right: 2px solid var(--win-light);
            border-bottom: 2px solid var(--win-light);
        }
        .layer-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px;
            cursor: pointer;
            border: 1px dotted transparent;
            font-size: 1.1rem;
        }
        .layer-item:hover {
            border: 1px dotted black;
        }
        .layer-item.active {
            background: var(--win-blue);
            color: white;
        }
        .layer-vis {
            min-width: 20px;
            text-align: center;
            font-weight: bold;
            cursor: pointer;
        }
        .layer-thumb {
            width: 24px;
            height: 24px;
            border: 1px solid var(--win-dark);
            background: #ccc;
            object-fit: contain;
        }
    </style>
</head>
<body>

<div class="main-window bevel-up">
    <!-- Title Bar -->
    <div class="title-bar">
        <span>RETRO PIXEL LAB v3.2</span>
        <div class="flex gap-1">
            <button class="bevel-up bevel-btn px-2 font-bold text-black border-none bg-gray-300">_</button>
            <button class="bevel-up bevel-btn px-2 font-bold text-black border-none bg-gray-300">X</button>
        </div>
    </div>

    <!-- Menu Bar -->
    <div class="menu-bar">
        <div class="menu-item" id="menuBtnFile">
            <u>F</u>ile
            <div class="dropdown" id="dropdownFile">
                <div class="dropdown-item" id="menuLoad">Load Image...</div>
                <div class="dropdown-separator"></div>
                <div class="dropdown-item" id="menuSave">Save to Disk</div>
            </div>
        </div>
        <div class="menu-item" id="menuBtnPref">
            <u>P</u>references
            <div class="dropdown" id="dropdownPref">
                <div class="dropdown-item disabled font-bold bg-gray-200" style="cursor:default">Export Scale</div>
                <div class="dropdown-separator"></div>
                <div class="dropdown-item scale-opt" data-scale="1"><span>1x (Original)</span> <span id="check-scale-1">✓</span></div>
                <div class="dropdown-item scale-opt" data-scale="2"><span>2x</span> <span id="check-scale-2"></span></div>
                <div class="dropdown-item scale-opt" data-scale="4"><span>4x</span> <span id="check-scale-4"></span></div>
                <div class="dropdown-item scale-opt" data-scale="8"><span>8x</span> <span id="check-scale-8"></span></div>
                <div class="dropdown-separator"></div>
                <div class="dropdown-item" id="menuZoomSnap"><span>Snap Zoom (100%)</span> <span id="check-zoom-snap">✓</span></div>
            </div>
        </div>
        <input type="file" id="fileInput" accept="image/*" class="hidden">
    </div>

    <!-- Main Content -->
    <div class="app-body">
        
        <!-- Sidebar -->
        <div class="sidebar">
            
            <!-- Tools -->
            <div class="group-box bevel-down">
                <span class="group-label">TOOLS</span>
                <div class="flex gap-1 mt-1">
                    <button id="toolMove" class="bevel-up bevel-btn flex-1 py-1 font-bold text-sm tool-btn" title="Move Layer (V)">MOVE</button>
                    <button id="toolHand" class="bevel-up bevel-btn flex-1 py-1 font-bold text-sm tool-btn" title="Pan View (H/Space)">HAND</button>
                    <button id="toolPick" class="bevel-up bevel-btn flex-1 py-1 font-bold text-sm tool-btn" title="Mask Key Picker (I)">PICK</button>
                </div>
            </div>

            <!-- Layer List -->
            <div class="group-box bevel-down flex flex-col" style="min-height: 180px; max-height: 180px;">
                <span class="group-label">LAYERS</span>
                <div id="layerList" class="flex-1 overflow-y-auto bg-white border border-gray-400 p-1 flex flex-col gap-1 mt-1">
                    <!-- Layers injected here -->
                </div>
                <div class="flex justify-between mt-2">
                    <button id="btnLayerUp" class="bevel-up bevel-btn px-3 text-xs font-bold">▲</button>
                    <button id="btnLayerDown" class="bevel-up bevel-btn px-3 text-xs font-bold">▼</button>
                    <button id="btnLayerDel" class="bevel-up bevel-btn px-2 text-xs bg-red-200 font-bold">DEL</button>
                </div>
            </div>

            <!-- Layer Masking -->
            <div class="group-box bevel-down" id="groupMasking">
                <span class="group-label">LAYER MASKING</span>
                <div class="flex items-center gap-2 mb-1 mt-1">
                    <label class="flex items-center text-sm cursor-pointer select-none">
                        <input type="checkbox" id="chkMask" class="w31-checkbox">
                        <span>ENABLE</span>
                    </label>
                    <div class="flex-1 flex gap-1 items-center">
                        <div id="maskColorPreview" class="w-6 h-6 border border-black bg-green-500 cursor-pointer" title="Click to pick color"></div>
                        <input type="text" id="inpMaskHex" class="w-full text-xs font-mono border border-gray-400 px-1 h-6" value="#00FF00">
                    </div>
                </div>
                <div class="flex items-center gap-2 mb-1">
                    <label class="w-8 text-sm">THR</label>
                    <input type="range" id="inpMaskThresh" min="0" max="100" value="10">
                    <input type="number" id="valMaskThresh" class="w31-num" value="10">
                </div>
                <div class="flex items-center gap-2 mb-1">
                    <label class="w-8 text-sm">SFT</label>
                    <input type="range" id="inpMaskSoft" min="0" max="50" value="0">
                    <input type="number" id="valMaskSoft" class="w31-num" value="0">
                </div>
            </div>

            <!-- Horizontal Scale (Editable) -->
            <div class="group-box bevel-down">
                <span class="group-label">HORIZONTAL SCALE</span>
                <div class="flex flex-col gap-1 mt-1">
                    <div class="flex justify-between items-end px-1">
                         <div class="flex items-center gap-1">
                             <input type="number" id="valRes" class="w31-num w-16" value="160">
                             <span class="text-sm">px</span>
                         </div>
                         <label class="flex items-center text-sm cursor-pointer select-none">
                            <input type="checkbox" id="chkSnap" checked class="w31-checkbox">
                            <span>SNAP 32px</span>
                        </label>
                    </div>
                    <input type="range" id="inpRes" min="32" max="640" step="32" value="160" class="w-full">
                </div>
            </div>

            <!-- Color Adjust (Editable) -->
            <div class="group-box bevel-down">
                <span class="group-label">COLOR ADJUST</span>
                <div class="flex items-center gap-2 mb-1 mt-1">
                    <label class="w-8 text-sm">CON</label>
                    <input type="range" id="inpContrast" min="-100" max="100" value="0">
                    <input type="number" id="valContrast" class="w31-num" value="0">
                </div>
                <div class="flex items-center gap-2 mb-1">
                    <label class="w-8 text-sm">BRI</label>
                    <input type="range" id="inpBrightness" min="-100" max="100" value="0">
                    <input type="number" id="valBrightness" class="w31-num" value="0">
                </div>
                <div class="flex items-center gap-2 mb-1">
                    <label class="w-8 text-sm">SAT</label>
                    <input type="range" id="inpSat" min="0" max="200" value="100">
                    <input type="number" id="valSat" class="w31-num" value="100">
                </div>
            </div>

            <!-- Palette & Dither -->
            <div class="group-box bevel-down">
                <span class="group-label">GPU PROCESS</span>
                
                <div class="flex justify-between items-center mb-1 mt-1">
                    <label class="block text-sm">Palette Mode</label>
                    <label class="flex items-center text-sm cursor-pointer select-none">
                        <input type="checkbox" id="chkRedmean" checked class="w31-checkbox">
                        <span class="text-xs font-bold" title="Better human color perception matching">REDMEAN</span>
                    </label>
                </div>

                <select id="selPalette" class="mb-2 w-full p-1 text-lg">
                    <optgroup label="Auto Extraction">
                        <option value="auto8">Auto (8 Colors)</option>
                        <option value="auto16" selected>Auto (16 Colors)</option>
                        <option value="auto32">Auto (32 Colors)</option>
                    </optgroup>
                    <optgroup label="Procedural Math">
                        <option value="math_dynamic_xy">Math: Dynamic XY (Dual Axis)</option>
                        <option value="math_rgb_split">Math: RGB Split (Tri Axis)</option>
                        <option value="math_luma_chroma">Math: Luma/Chroma (Dual Axis)</option>
                        <option value="math_bitcrush">Math: Bitcrush (Dual Axis)</option>
                        <option value="math_quant_rgb">RGB Quant (Uniform)</option>
                        <option value="math_quant_hsv">HSV Quant (Uniform)</option>
                    </optgroup>
                    <optgroup label="Retro Hardware">
                        <option value="bw">1-Bit Macintosh</option>
                        <option value="gb">Gameboy (4 Greens)</option>
                        <option value="cga1">CGA (Cyan/Mag)</option>
                        <option value="cga2">CGA (Red/Grn)</option>
                        <option value="c64">Commodore 64</option>
                        <option value="nes">NES (Famicom)</option>
                        <option value="ega">EGA (16 Colors)</option>
                        <option value="vga">VGA (256 Colors)</option>
                    </optgroup>
                    <optgroup label="Artistic">
                        <option value="vapor">Vaporwave</option>
                        <option value="matrix">Matrix Code</option>
                        <option value="redscale">Virtual Boy</option>
                    </optgroup>
                </select>

                <!-- Dynamic Math Controls (Already had inputs, refined) -->
                <div id="mathControls">
                    <div class="mb-1 hidden" id="wrapAxis1">
                        <label class="text-sm block" id="lblAxis1">Axis 1</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="inpAxis1" min="0" max="100" value="30">
                            <input type="number" id="numAxis1" value="8" class="w31-num">
                        </div>
                    </div>
                    <div class="mb-1 hidden" id="wrapAxis2">
                        <label class="text-sm block" id="lblAxis2">Axis 2</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="inpAxis2" min="0" max="100" value="50">
                            <input type="number" id="numAxis2" value="50" class="w31-num">
                        </div>
                    </div>
                    <div class="mb-3 hidden" id="wrapAxis3">
                        <label class="text-sm block" id="lblAxis3">Axis 3</label>
                        <div class="flex items-center gap-2">
                            <input type="range" id="inpAxis3" min="0" max="100" value="30">
                            <input type="number" id="numAxis3" value="8" class="w31-num">
                        </div>
                    </div>
                </div>

                <!-- Dither Mixing (Added Inputs) -->
                <label class="block mb-1 text-sm font-bold">Dither Mixing</label>
                <div class="p-2 border border-gray-400 bg-gray-100 mb-2 box-shadow-inner">
                    <div class="mb-1">
                        <label class="text-xs">Algo A</label>
                        <select id="selDither" class="text-sm h-7 w-full border border-gray-500">
                            <option value="bayer4">Ordered 4x4</option>
                            <option value="bayer2">Ordered 2x2</option>
                            <option value="bayer8" selected>Ordered 8x8</option>
                            <option value="floyd">Floyd-Steinberg</option>
                            <option value="falsefloyd">False Floyd-Steinberg</option>
                            <option value="atkinson">Atkinson</option>
                            <option value="jjn">Jarvis, Judice & Ninke</option>
                            <option value="sierra">Sierra Lite</option>
                            <option value="stucki">Stucki</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <div class="mb-1">
                        <label class="text-xs">Algo B</label>
                        <select id="selDither2" class="text-sm h-7 w-full border border-gray-500">
                            <option value="none">None</option>
                            <option value="bayer4">Ordered 4x4</option>
                            <option value="bayer2">Ordered 2x2</option>
                            <option value="bayer8">Ordered 8x8</option>
                            <option value="floyd">Floyd-Steinberg</option>
                            <option value="falsefloyd">False Floyd-Steinberg</option>
                            <option value="atkinson">Atkinson</option>
                            <option value="jjn" selected>Jarvis, Judice & Ninke</option>
                            <option value="sierra">Sierra Lite</option>
                            <option value="stucki">Stucki</option>
                        </select>
                    </div>
                    
                    <div class="flex items-center gap-2 mt-2">
                        <label class="text-xs w-8">MIX</label>
                        <input type="range" id="inpDitherMix" min="0" max="100" value="50">
                        <input type="number" id="valDitherMix" class="w31-num" value="50">
                    </div>
                </div>

                <div class="flex items-center gap-2">
                    <label class="w-12 text-sm">AMT</label>
                    <input type="range" id="inpDitherAmt" min="0" max="100" value="50">
                    <input type="number" id="valDitherAmt" class="w31-num" value="50">
                </div>
            </div>
            
            <button id="btnCompare" class="bevel-up bevel-btn w-full py-2 font-bold mb-4 bg-yellow-100 text-sm">HOLD TO COMPARE</button>

        </div>

        <!-- Viewport -->
        <div class="viewport-container checker-bg bevel-down" id="viewport">
            <div id="canvasWrapper">
                <canvas id="mainCanvas"></canvas>
            </div>
            <div id="dragOverlay" class="overlay-msg hidden"><span>DROP IMAGE HERE</span></div>
            <div id="loadingOverlay" class="overlay-msg hidden">
                <span class="animate-pulse">PROCESSING...</span>
                <span class="text-sm mt-2">PLEASE WAIT</span>
            </div>
        </div>

    </div>

    <!-- Footer -->
    <div class="status-bar bevel-up flex justify-between px-2 py-1 bg-gray-300 border-t-2 border-white">
        <span id="statusMsg">READY.</span>
        <div>
            <span id="statusZoom" class="mr-4">100%</span>
            <span id="statusRes">0 x 0</span>
        </div>
    </div>
</div>

<script>
/**
 * RETRO PIXEL LAB v3.2
 * - Editable Slider Values
 * - Zoom Snap (100% Increments) & Status
 * - Zoom Preferences
 */

/**
 * Global constants used throughout the application.
 * @constant
 * @type {Object}
 * @property {number} LUMA_R - Red coefficient for luma calculation.
 * @property {number} LUMA_G - Green coefficient for luma calculation.
 * @property {number} LUMA_B - Blue coefficient for luma calculation.
 * @property {number[]} RESOLUTION_STOPS - Pre-calculated resolution stops.
 * @property {number[][]} BAYER4 - 4x4 Bayer matrix for ordered dithering.
 * @property {number[][]} BAYER8 - 8x8 Bayer matrix for ordered dithering.
 */
const CONSTANTS = {
    LUMA_R: 0.299,
    LUMA_G: 0.587,
    LUMA_B: 0.114,
    RESOLUTION_STOPS: Array.from({length: 20}, (_, i) => (i + 1) * 32),
    BAYER4: [[0, 8, 2, 10],[12, 4, 14, 6],[3, 11, 1, 9],[15, 7, 13, 5]],
    BAYER8: [
        [ 0, 48, 12, 60,  3, 51, 15, 63],
        [32, 16, 44, 28, 35, 19, 47, 31],
        [ 8, 56,  4, 52, 11, 59,  7, 55],
        [40, 24, 36, 20, 43, 27, 39, 23],
        [ 2, 50, 14, 62,  1, 49, 13, 61],
        [34, 18, 46, 30, 33, 17, 45, 29],
        [10, 58,  6, 54,  9, 57,  5, 53],
        [42, 26, 38, 22, 41, 25, 37, 21]
    ]
};

/**
 * Collection of color palettes.
 * Each palette is an array of RGB arrays [r, g, b].
 * @constant
 * @type {Object.<string, number[][]>}
 */
const PALETTES = {
    'bw': [[0,0,0], [255,255,255]],
    'gb': [[15,56,15], [48,98,48], [139,172,15], [155,188,15]],
    'cga1': [[0,0,0], [85,255,255], [255,85,255], [255,255,255]],
    'cga2': [[0,0,0], [85,255,85], [255,85,85], [255,255,85]],
    'ega': [
        [0,0,0],[0,0,170],[0,170,0],[0,170,170],[170,0,0],[170,0,170],[170,85,0],[170,170,170],
        [85,85,85],[85,85,255],[85,255,85],[85,255,255],[255,85,85],[255,85,255],[255,255,85],[255,255,255]
    ],
    'c64': [
        [0,0,0],[255,255,255],[136,0,0],[170,255,238],[204,68,204],[0,204,85],[0,0,170],[238,238,119],
        [221,136,85],[102,68,0],[255,119,119],[51,51,51],[119,119,119],[170,255,102],[0,136,255],[187,187,187]
    ],
    'nes': [
        [124,124,124], [0,0,252], [0,0,188], [68,40,188], [148,0,132], [168,0,32], [168,16,0], [136,20,0],
        [80,48,0], [0,120,0], [0,104,0], [0,88,0], [0,64,88], [0,0,0], [0,0,0], [0,0,0],
        [188,188,188], [0,120,248], [0,88,248], [104,68,252], [216,0,204], [228,0,88], [248,56,0], [228,92,16],
        [172,124,0], [0,184,0], [0,168,0], [0,168,68], [0,136,136], [0,0,0], [0,0,0], [0,0,0],
        [248,248,248], [60,188,252], [104,136,252], [152,120,248], [248,120,248], [248,88,152], [248,120,88], [252,160,68],
        [248,184,0], [184,248,24], [88,216,84], [88,248,152], [0,232,216], [120,120,120], [0,0,0], [0,0,0],
        [252,252,252], [164,228,252], [184,184,248], [216,184,248], [248,184,248], [248,164,192], [240,208,176], [252,224,168],
        [248,216,120], [216,248,120], [184,248,184], [184,248,216], [0,252,252], [248,216,248], [0,0,0], [0,0,0]
    ],
    'vapor': [[255,113,206], [1,205,254], [5,255,161], [185,103,255], [255,251,150], [20,20,40], [60,20,60], [255,255,255]],
    'redscale': [[0,0,0], [50,0,0], [100,0,0], [150,0,0], [200,0,0], [255,0,0]],
    'matrix': [[0,0,0], [0,50,0], [0,100,0], [0,150,0], [0,200,0], [0,255,0], [200,255,200]]
};

/**
 * Generates the standard VGA 256 color palette.
 * @returns {number[][]} An array of 256 colors, each representing [r, g, b].
 */
const generateVGA = () => {
    const p = [
        [0,0,0], [0,0,170], [0,170,0], [0,170,170], [170,0,0], [170,0,170], [170,85,0], [170,170,170],
        [85,85,85], [85,85,255], [85,255,85], [85,255,255], [255,85,85], [255,85,255], [255,255,85], [255,255,255]
    ];
    for(let i=0; i<16; i++) p.push([Math.floor(i*(255/15)),Math.floor(i*(255/15)),Math.floor(i*(255/15))]);
    for(let r=0; r<6; r++) for(let g=0; g<6; g++) for(let b=0; b<6; b++) p.push([r*51, g*51, b*51]);
    return p.slice(0, 256);
};
PALETTES['vga'] = generateVGA();

/**
 * Utility class for color calculations and conversions.
 */
class ColorUtils {
    /**
     * Calculates the squared Euclidean distance between two colors.
     * @param {number[]} c1 - First color [r, g, b].
     * @param {number[]} c2 - Second color [r, g, b].
     * @returns {number} The squared distance.
     */
    static distEuclidean(c1, c2) { return (c1[0]-c2[0])**2 + (c1[1]-c2[1])**2 + (c1[2]-c2[2])**2; }

    /**
     * Calculates the Redmean color distance between two colors.
     * This approximates human color perception better than Euclidean distance.
     * @param {number[]} c1 - First color [r, g, b].
     * @param {number[]} c2 - Second color [r, g, b].
     * @returns {number} The weighted squared distance.
     */
    static distRedmean(c1, c2) {
        let rMean = (c1[0] + c2[0]) / 2;
        let r = c1[0] - c2[0], g = c1[1] - c2[1], b = c1[2] - c2[2];
        return (((512+rMean)*r*r)>>8) + 4*g*g + (((767-rMean)*b*b)>>8);
    }

    /**
     * Converts RGB color space to HSV.
     * @param {number} r - Red (0-255).
     * @param {number} g - Green (0-255).
     * @param {number} b - Blue (0-255).
     * @returns {number[]} The HSV representation [h, s, v] where h, s, v are 0-1.
     */
    static rgbToHsv(r, g, b) {
        r/=255, g/=255, b/=255;
        let max = Math.max(r,g,b), min = Math.min(r,g,b);
        let h, s, v = max, d = max - min;
        s = max == 0 ? 0 : d / max;
        if (max == min) h = 0;
        else {
            switch (max) {
                case r: h = (g-b)/d+(g<b?6:0); break;
                case g: h = (b-r)/d+2; break;
                case b: h = (r-g)/d+4; break;
            }
            h /= 6;
        }
        return [h, s, v];
    }

    /**
     * Converts HSV color space to RGB.
     * @param {number} h - Hue (0-1).
     * @param {number} s - Saturation (0-1).
     * @param {number} v - Value (0-1).
     * @returns {number[]} The RGB representation [r, g, b] (0-255).
     */
    static hsvToRgb(h, s, v) {
        let r, g, b, i = Math.floor(h*6), f=h*6-i, p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
        switch (i%6) {
            case 0: r=v,g=t,b=p; break; case 1: r=q,g=v,b=p; break; case 2: r=p,g=v,b=t; break;
            case 3: r=p,g=q,b=v; break; case 4: r=t,g=p,b=v; break; case 5: r=v,g=p,b=q; break;
        }
        return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
    }

    /**
     * Converts RGB color space to YIQ.
     * @param {number} r - Red (0-255).
     * @param {number} g - Green (0-255).
     * @param {number} b - Blue (0-255).
     * @returns {number[]} The YIQ representation [y, i, q].
     */
    static rgbToYiq(r, g, b) {
        return [CONSTANTS.LUMA_R*r + CONSTANTS.LUMA_G*g + CONSTANTS.LUMA_B*b, 0.596*r - 0.274*g - 0.322*b, 0.211*r - 0.523*g - 0.312*b];
    }

    /**
     * Converts YIQ color space to RGB.
     * @param {number} y - Luma component.
     * @param {number} i - In-phase component.
     * @param {number} q - Quadrature component.
     * @returns {number[]} The RGB representation [r, g, b] (0-255).
     */
    static yiqToRgb(y, i, q) {
        return [Math.max(0,Math.min(255, y+0.956*i+0.621*q)), Math.max(0,Math.min(255, y-0.272*i-0.647*q)), Math.max(0,Math.min(255, y-1.106*i+1.703*q))];
    }

    /**
     * Quantizes a value into a specific number of steps.
     * @param {number} val - The value to quantize (0-255).
     * @param {number} steps - The number of steps/levels.
     * @returns {number} The quantized value.
     */
    static quantizeVal(val, steps) {
        if (steps < 2) steps = 2;
        const stepSize = 255 / (steps - 1);
        return Math.floor(Math.round(val / stepSize) * stepSize);
    }
}

/**
 * Collection of dithering strategies (error diffusion and ordered).
 * @namespace
 */
const DitherStrategies = {
    /**
     * Helper to distribute quantization error to neighboring pixels.
     * @param {Uint8ClampedArray} data - The image pixel data.
     * @param {number} idx - Current pixel index.
     * @param {number} w - Image width.
     * @param {number} h - Image height.
     * @param {number} dx - X offset for error distribution.
     * @param {number} dy - Y offset for error distribution.
     * @param {number} factor - Error distribution factor.
     * @param {number} errR - Red error component.
     * @param {number} errG - Green error component.
     * @param {number} errB - Blue error component.
     */
    _distribute: (data, idx, w, h, dx, dy, factor, errR, errG, errB) => {
        const targetIdx = idx + (dy * w + dx) * 4;
        if(targetIdx < data.length && targetIdx > 0) {
            data[targetIdx] += errR * factor;
            data[targetIdx+1] += errG * factor;
            data[targetIdx+2] += errB * factor;
        }
    },
    'none': () => {},
    'bayer2': () => {},
    'bayer4': () => {},
    'bayer8': () => {},
    'floyd': (data, idx, w, h, er, eg, eb) => {
        const d = DitherStrategies._distribute;
        d(data, idx, w, h, 1, 0, 7/16, er, eg, eb);
        d(data, idx, w, h, -1, 1, 3/16, er, eg, eb);
        d(data, idx, w, h, 0, 1, 5/16, er, eg, eb);
        d(data, idx, w, h, 1, 1, 1/16, er, eg, eb);
    },
    'falsefloyd': (data, idx, w, h, er, eg, eb) => {
        const d = DitherStrategies._distribute;
        d(data, idx, w, h, 1, 0, 3/8, er, eg, eb);
        d(data, idx, w, h, 0, 1, 3/8, er, eg, eb);
        d(data, idx, w, h, 1, 1, 2/8, er, eg, eb);
    },
    'atkinson': (data, idx, w, h, er, eg, eb) => {
        const d = DitherStrategies._distribute;
        const f = 1/8;
        d(data, idx, w, h, 1, 0, f, er, eg, eb);
        d(data, idx, w, h, 2, 0, f, er, eg, eb);
        d(data, idx, w, h, -1, 1, f, er, eg, eb);
        d(data, idx, w, h, 0, 1, f, er, eg, eb);
        d(data, idx, w, h, 1, 1, f, er, eg, eb);
        d(data, idx, w, h, 0, 2, f, er, eg, eb);
    },
    'jjn': (data, idx, w, h, er, eg, eb) => {
        const d = DitherStrategies._distribute;
        d(data, idx, w, h, 1, 0, 7/48, er, eg, eb); d(data, idx, w, h, 2, 0, 5/48, er, eg, eb);
        d(data, idx, w, h, -2, 1, 3/48, er, eg, eb); d(data, idx, w, h, -1, 1, 5/48, er, eg, eb);
        d(data, idx, w, h, 0, 1, 7/48, er, eg, eb); d(data, idx, w, h, 1, 1, 5/48, er, eg, eb); d(data, idx, w, h, 2, 1, 3/48, er, eg, eb);
        d(data, idx, w, h, -2, 2, 1/48, er, eg, eb); d(data, idx, w, h, -1, 2, 3/48, er, eg, eb);
        d(data, idx, w, h, 0, 2, 5/48, er, eg, eb); d(data, idx, w, h, 1, 2, 3/48, er, eg, eb); d(data, idx, w, h, 2, 2, 1/48, er, eg, eb);
    },
    'sierra': (data, idx, w, h, er, eg, eb) => {
        const d = DitherStrategies._distribute;
        d(data, idx, w, h, 1, 0, 2/4, er, eg, eb); d(data, idx, w, h, -1, 1, 1/4, er, eg, eb); d(data, idx, w, h, 0, 1, 1/4, er, eg, eb);
    },
    'stucki': (data, idx, w, h, er, eg, eb) => {
        const d = DitherStrategies._distribute;
        const f = 1/42;
        d(data, idx, w, h, 1,0, 8*f, er, eg, eb); d(data, idx, w, h, 2,0, 4*f, er, eg, eb);
        d(data, idx, w, h, -2,1, 2*f, er, eg, eb); d(data, idx, w, h, -1,1, 4*f, er, eg, eb); d(data, idx, w, h, 0,1, 8*f, er, eg, eb); d(data, idx, w, h, 1,1, 4*f, er, eg, eb); d(data, idx, w, h, 2,1, 2*f, er, eg, eb);
        d(data, idx, w, h, -2,2, 1*f, er, eg, eb); d(data, idx, w, h, -1,2, 2*f, er, eg, eb); d(data, idx, w, h, 0,2, 4*f, er, eg, eb); d(data, idx, w, h, 1,2, 2*f, er, eg, eb); d(data, idx, w, h, 2,2, 1*f, er, eg, eb);
    }
};

/**
 * Represents a single image layer with position, visibility, and masking.
 */
class Layer {
    constructor(id, name, img, x, y) {
        this.id = id;
        this.name = name;
        this.img = img;
        this.x = x;
        this.y = y;
        this.visible = true;
        this.mask = {
            enabled: false,
            color: {r: 0, g: 255, b: 0},
            threshold: 10,
            softness: 0
        };
        this.cacheCanvas = document.createElement('canvas');
        this.cacheCtx = this.cacheCanvas.getContext('2d');
        this.isDirty = true;
        this.updateCache();
    }

    setMaskColor(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if(result) {
            this.mask.color = {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            };
            this.isDirty = true;
        }
    }

    getMaskHex() {
        const c = this.mask.color;
        return "#" + ((1 << 24) + (c.r << 16) + (c.g << 8) + c.b).toString(16).slice(1).toUpperCase();
    }

    updateCache() {
        this.cacheCanvas.width = this.img.width;
        this.cacheCanvas.height = this.img.height;
        this.cacheCtx.drawImage(this.img, 0, 0);

        if (this.mask.enabled) {
            const w = this.img.width, h = this.img.height;
            const imgData = this.cacheCtx.getImageData(0, 0, w, h);
            const data = imgData.data;
            const key = this.mask.color;
            const thresh = (this.mask.threshold / 100) * 442; // Max Euclidean dist is sqrt(255^2 * 3) ~ 441.6
            const soft = (this.mask.softness / 50) * 100; // arbitrary scale

            for(let i=0; i<data.length; i+=4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                const dist = Math.sqrt((r-key.r)**2 + (g-key.g)**2 + (b-key.b)**2);

                if (dist < thresh) {
                    data[i+3] = 0;
                } else if (dist < thresh + soft) {
                    const alpha = (dist - thresh) / soft;
                    data[i+3] = Math.floor(alpha * 255);
                }
            }
            this.cacheCtx.putImageData(imgData, 0, 0);
        }
        this.isDirty = false;
    }

    getCanvas() {
        if(this.isDirty) this.updateCache();
        return this.cacheCanvas;
    }
}

/**
 * Manages the stack of layers and composition.
 */
class LayerManager {
    constructor(redrawCallback) {
        this.layers = [];
        this.activeLayerId = null;
        this.width = 0;
        this.height = 0;
        this.redraw = redrawCallback; // Callback to trigger app process
        this.uiUpdateCallback = null; // Callback to update layer list UI
    }

    addLayer(img, name) {
        const id = Date.now().toString();
        // If first layer, set base dimensions
        if (this.layers.length === 0) {
            this.width = img.width;
            this.height = img.height;
            // Center? No, just 0,0
            const layer = new Layer(id, name, img, 0, 0);
            this.layers.push(layer);
        } else {
            // Center new layer
            const x = Math.floor((this.width - img.width) / 2);
            const y = Math.floor((this.height - img.height) / 2);
            const layer = new Layer(id, name, img, x, y);
            this.layers.push(layer);
        }
        this.activeLayerId = id;
        if(this.uiUpdateCallback) this.uiUpdateCallback();
        return id;
    }

    getActive() {
        return this.layers.find(l => l.id === this.activeLayerId);
    }

    setActive(id) {
        this.activeLayerId = id;
        if(this.uiUpdateCallback) this.uiUpdateCallback();
    }

    moveActive(dx, dy) {
        const l = this.getActive();
        if(l) { l.x += dx; l.y += dy; this.redraw(); }
    }

    toggleVis(id) {
        const l = this.layers.find(l => l.id === id);
        if(l) {
            l.visible = !l.visible;
            if(this.uiUpdateCallback) this.uiUpdateCallback();
            this.redraw();
        }
    }

    deleteActive() {
        if(!this.activeLayerId) return;
        const idx = this.layers.findIndex(l => l.id === this.activeLayerId);
        if(idx >= 0) {
            this.layers.splice(idx, 1);
            if(this.layers.length > 0) {
                // Select next available
                const newIdx = Math.min(idx, this.layers.length-1);
                this.activeLayerId = this.layers[newIdx].id;
            } else {
                this.activeLayerId = null;
            }
            if(this.uiUpdateCallback) this.uiUpdateCallback();
            this.redraw();
        }
    }

    moveOrder(dir) { // -1 (down) or 1 (up)
        if(!this.activeLayerId) return;
        const idx = this.layers.findIndex(l => l.id === this.activeLayerId);
        if(idx < 0) return;

        const newIdx = idx + dir;
        // Check bounds. Arrays: 0 is bottom, length-1 is top?
        // Rendering: iterate 0..len. So 0 is bottom (background).
        // UI: List usually shows top at top.
        // So "Up" means higher index. "Down" means lower index.

        if(newIdx >= 0 && newIdx < this.layers.length) {
            const temp = this.layers[idx];
            this.layers[idx] = this.layers[newIdx];
            this.layers[newIdx] = temp;
            if(this.uiUpdateCallback) this.uiUpdateCallback();
            this.redraw();
        }
    }

    getComposite() {
        const cvs = document.createElement('canvas');
        cvs.width = this.width || 1;
        cvs.height = this.height || 1;
        const ctx = cvs.getContext('2d');

        // Fill background? Maybe transparent.

        this.layers.forEach(l => {
            if(l.visible) {
                ctx.drawImage(l.getCanvas(), l.x, l.y);
            }
        });
        return cvs;
    }
}

/**
 * Handles image loading, processing, and pixel manipulation.
 */
class ImageProcessor {
    /**
     * Creates an instance of ImageProcessor.
     */
    constructor() {
        this.srcCanvas = document.createElement('canvas');
        this.srcCtx = this.srcCanvas.getContext('2d');
        this.width = 0;
        this.height = 0;
    }

    /**
     * Loads an image into the processor's source canvas.
     * @param {HTMLImageElement} img - The source image element.
     */
    loadImage(source) {
        if(source instanceof HTMLImageElement || source instanceof HTMLCanvasElement) {
            this.width = source.width;
            this.height = source.height;
            this.srcCanvas.width = this.width;
            this.srcCanvas.height = this.height;
            this.srcCtx.clearRect(0, 0, this.width, this.height);
            this.srcCtx.drawImage(source, 0, 0);
        }
    }

    /**
     * Finds the closest matching color in a palette.
     * @param {number} r - Red component.
     * @param {number} g - Green component.
     * @param {number} b - Blue component.
     * @param {number[][]} palette - Array of available colors.
     * @param {boolean} useRedmean - Whether to use Redmean distance (true) or Euclidean (false).
     * @param {Map} cache - Cache for color lookups.
     * @returns {number[]} The closest matching color [r, g, b].
     */
    findClosest(r, g, b, palette, useRedmean, cache) {
        const ri = Math.round(r), gi = Math.round(g), bi = Math.round(b);
        const key = (ri << 16) | (gi << 8) | bi;
        if (cache.has(key)) return cache.get(key);
        let minD = Infinity, best = palette[0], target = [r, g, b];
        for(let i = 0; i < palette.length; i++) {
            const d = useRedmean ? ColorUtils.distRedmean(target, palette[i]) : ColorUtils.distEuclidean(target, palette[i]);
            if(d < minD) { minD = d; best = palette[i]; if(d === 0) break; }
        }
        cache.set(key, best);
        return best;
    }

    /**
     * Processes the loaded image with the given options.
     * Uses a generator to allow non-blocking processing (chunking).
     * @param {Object} options - Processing configuration (resolution, palette, dithering, etc.).
     * @param {function} onProgress - Callback for progress updates (0-1).
     * @param {function} onComplete - Callback with the final ImageData.
     */
    async process(options, onProgress, onComplete) {
        const { targetWidth, contrast, brightness, saturation, ditherType1, ditherType2, ditherMix, ditherAmt, paletteId, axis1, axis2, axis3, useRedmean } = options;
        const scale = targetWidth / this.width;
        const targetHeight = Math.floor(this.height * scale);
        
        const workCanvas = document.createElement('canvas');
        workCanvas.width = targetWidth;
        workCanvas.height = targetHeight;
        const ctx = workCanvas.getContext('2d');
        
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(this.srcCanvas, 0, 0, targetWidth, targetHeight);
        
        let idata = ctx.getImageData(0, 0, targetWidth, targetHeight);
        let data = idata.data;
        const len = data.length;
        const bVal = brightness;
        const cFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));
        
        for (let i = 0; i < len; i += 4) {
            let r = data[i], g = data[i+1], b = data[i+2];
            r = cFactor * (r - 128) + 128 + bVal;
            g = cFactor * (g - 128) + 128 + bVal;
            b = cFactor * (b - 128) + 128 + bVal;
            if (saturation !== 100) {
                const gray = CONSTANTS.LUMA_R * r + CONSTANTS.LUMA_G * g + CONSTANTS.LUMA_B * b;
                const sVal = saturation / 100;
                r = gray + (r - gray) * sVal;
                g = gray + (g - gray) * sVal;
                b = gray + (b - gray) * sVal;
            }
            data[i] = Math.max(0, Math.min(255, r));
            data[i+1] = Math.max(0, Math.min(255, g));
            data[i+2] = Math.max(0, Math.min(255, b));
        }

        let palette;
        let isMathMode = paletteId.startsWith('math_');
        if (!isMathMode) {
            if (paletteId.startsWith('auto')) {
                const count = parseInt(paletteId.replace('auto',''));
                if(count === 8) palette = PALETTES.cga1.concat(PALETTES.cga2); 
                else if(count === 32) palette = PALETTES.vga.slice(0, 32); 
                else palette = PALETTES.ega; 
            } else { palette = PALETTES[paletteId] || PALETTES.vga; }
        }

        const dAmt = ditherAmt / 100, mix = ditherMix / 100, w = targetWidth, h = targetHeight;
        const spatialCache = new Map();
        const strategy1 = DitherStrategies[ditherType1] || DitherStrategies['none'];
        const strategy2 = DitherStrategies[ditherType2] || DitherStrategies['none'];
        const isBayer1 = ditherType1.startsWith('bayer');
        const isBayer2 = ditherType2.startsWith('bayer');

        const processChunk = function* () {
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;
                    let r = data[idx], g = data[idx+1], b = data[idx+2];
                    let offset = 0;
                    if (isBayer1 || isBayer2) {
                        const m = (ditherType1 === 'bayer8' || ditherType2 === 'bayer8') ? CONSTANTS.BAYER8 : CONSTANTS.BAYER4;
                        const dim = m.length;
                        const th = m[y%dim][x%dim];
                        const bayVal = ((th / (dim*dim)) - 0.5) * 64;
                        if(isBayer1 && !isBayer2) offset = bayVal * (1-mix);
                        else if(!isBayer1 && isBayer2) offset = bayVal * mix;
                        else offset = bayVal; 
                    }
                    const dOffset = offset * dAmt;
                    let dR = r + dOffset, dG = g + dOffset, dB = b + dOffset;
                    let finalColor;

                    if (isMathMode) {
                        dR = Math.max(0, Math.min(255, dR)); dG = Math.max(0, Math.min(255, dG)); dB = Math.max(0, Math.min(255, dB));
                        if (paletteId === 'math_dynamic_xy') {
                            const qs = axis1, quantBias = (axis2 / 256) * 100;
                            let rSteps = qs, gSteps = qs, bSteps = Math.max(2, qs / 2);
                            if (quantBias < 50) { rSteps = Math.max(2, Math.floor(qs * (quantBias/50))); bSteps = Math.max(2, qs - rSteps + 2); } 
                            else { gSteps = Math.max(2, Math.floor(qs * ((100-quantBias)/50))); bSteps = Math.max(2, qs - gSteps + 2); }
                            finalColor = [ColorUtils.quantizeVal(dR, rSteps), ColorUtils.quantizeVal(dG, gSteps), ColorUtils.quantizeVal(dB, bSteps)];
                        }
                        else if (paletteId === 'math_rgb_split') finalColor = [ColorUtils.quantizeVal(dR, axis1), ColorUtils.quantizeVal(dG, axis2), ColorUtils.quantizeVal(dB, axis3)];
                        else if (paletteId === 'math_luma_chroma') {
                            const yiq = ColorUtils.rgbToYiq(dR, dG, dB);
                            let qY = ColorUtils.quantizeVal(yiq[0], axis1);
                            const qSteps = axis2, stepSize = 300 / qSteps;
                            let qI = Math.round(yiq[1] / stepSize) * stepSize, qQ = Math.round(yiq[2] / stepSize) * stepSize;
                            finalColor = ColorUtils.yiqToRgb(qY, qI, qQ);
                        }
                        else if (paletteId === 'math_bitcrush') {
                             const bright = (dR+dG+dB)/3;
                             finalColor = bright < axis2 ? [0,0,0] : [ColorUtils.quantizeVal(dR, axis1), ColorUtils.quantizeVal(dG, axis1), ColorUtils.quantizeVal(dB, axis1)];
                        }
                        else if (paletteId === 'math_quant_rgb') finalColor = [ColorUtils.quantizeVal(dR, axis1), ColorUtils.quantizeVal(dG, axis1), ColorUtils.quantizeVal(dB, axis1)];
                        else if (paletteId === 'math_quant_hsv') {
                            const hsv = ColorUtils.rgbToHsv(dR, dG, dB);
                            hsv[0] = Math.floor(hsv[0] * axis1) / axis1; hsv[1] = Math.floor(hsv[1] * axis1) / axis1; hsv[2] = Math.floor(hsv[2] * axis1) / axis1;
                            finalColor = ColorUtils.hsvToRgb(hsv[0], hsv[1], hsv[2]);
                        } 
                    } else { finalColor = this.findClosest(dR, dG, dB, palette, useRedmean, spatialCache); }

                    data[idx] = finalColor[0]; data[idx+1] = finalColor[1]; data[idx+2] = finalColor[2];
                    const er = (r - dOffset - finalColor[0]) * dAmt, eg = (g - dOffset - finalColor[1]) * dAmt, eb = (b - dOffset - finalColor[2]) * dAmt;
                    if(!isBayer1) strategy1(data, idx, w, h, er, eg, eb, 1 - mix);
                    if(!isBayer2) strategy2(data, idx, w, h, er, eg, eb, mix);
                }
                if (y % 10 === 0) yield (y / h);
            }
        }.bind(this);

        const iterator = processChunk();
        const runLoop = () => {
            const start = performance.now();
            let res = iterator.next();
            while(!res.done && performance.now() - start < 12) res = iterator.next();
            if (res.done) onComplete(idata);
            else { onProgress(res.value); requestAnimationFrame(runLoop); }
        };
        runLoop();
    }
}

/**
 * Manages DOM elements and UI interactions.
 */
class UIManager {
    /**
     * Initializes the UI manager and caches DOM element references.
     */
    constructor() {
        this.els = {
            mainCanvas: document.getElementById('mainCanvas'),
            inpRes: document.getElementById('inpRes'),
            valRes: document.getElementById('valRes'),
            chkSnap: document.getElementById('chkSnap'),
            statusMsg: document.getElementById('statusMsg'),
            statusRes: document.getElementById('statusRes'),
            statusZoom: document.getElementById('statusZoom'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            canvasWrapper: document.getElementById('canvasWrapper'),
            viewport: document.getElementById('viewport'),
            dragOverlay: document.getElementById('dragOverlay'),
            fileInput: document.getElementById('fileInput'),
            inpAxis1: document.getElementById('inpAxis1'),
            inpAxis2: document.getElementById('inpAxis2'),
            inpAxis3: document.getElementById('inpAxis3'),
            numAxis1: document.getElementById('numAxis1'),
            numAxis2: document.getElementById('numAxis2'),
            numAxis3: document.getElementById('numAxis3'),
            wrapAxis1: document.getElementById('wrapAxis1'),
            wrapAxis2: document.getElementById('wrapAxis2'),
            wrapAxis3: document.getElementById('wrapAxis3'),
            lblAxis1: document.getElementById('lblAxis1'),
            lblAxis2: document.getElementById('lblAxis2'),
            lblAxis3: document.getElementById('lblAxis3'),
            selPalette: document.getElementById('selPalette'),
            btnCompare: document.getElementById('btnCompare'),
            menuBtnFile: document.getElementById('menuBtnFile'),
            dropdownFile: document.getElementById('dropdownFile'),
            menuBtnPref: document.getElementById('menuBtnPref'),
            dropdownPref: document.getElementById('dropdownPref'),
            menuLoad: document.getElementById('menuLoad'),
            menuSave: document.getElementById('menuSave'),
            menuZoomSnap: document.getElementById('menuZoomSnap'),
            checkZoomSnap: document.getElementById('check-zoom-snap'),
            valContrast: document.getElementById('valContrast'),
            valBrightness: document.getElementById('valBrightness'),
            valSat: document.getElementById('valSat'),
            valDitherMix: document.getElementById('valDitherMix'),
            valDitherAmt: document.getElementById('valDitherAmt'),
            // New UI
            toolMove: document.getElementById('toolMove'),
            toolHand: document.getElementById('toolHand'),
            toolPick: document.getElementById('toolPick'),
            layerList: document.getElementById('layerList'),
            btnLayerUp: document.getElementById('btnLayerUp'),
            btnLayerDown: document.getElementById('btnLayerDown'),
            btnLayerDel: document.getElementById('btnLayerDel'),
            groupMasking: document.getElementById('groupMasking'),
            chkMask: document.getElementById('chkMask'),
            maskColorPreview: document.getElementById('maskColorPreview'),
            inpMaskHex: document.getElementById('inpMaskHex'),
            inpMaskThresh: document.getElementById('inpMaskThresh'),
            valMaskThresh: document.getElementById('valMaskThresh'),
            inpMaskSoft: document.getElementById('inpMaskSoft'),
            valMaskSoft: document.getElementById('valMaskSoft'),
        };
    }
}

/**
 * Main application class connecting UI and ImageProcessor.
 */
class App {
    /**
     * Initializes the application, state, and listeners.
     */
    constructor() {
        this.ui = new UIManager();
        this.processor = new ImageProcessor();
        this.ctx = this.ui.els.mainCanvas.getContext('2d');
        
        // New Managers
        this.layerManager = new LayerManager(() => this.triggerProcess());
        this.layerManager.uiUpdateCallback = () => this.updateLayerUI();

        this.PALETTE_CONFIG = {
            'math_dynamic_xy': { labels: ['Steps', 'Bias (R/G)'], types: ['step', 'linear'], show: [true, true, false] },
            'math_rgb_split': { labels: ['R Steps', 'G Steps', 'B Steps'], types: ['step', 'step', 'step'], show: [true, true, true] },
            'math_luma_chroma': { labels: ['Luma', 'Chroma'], types: ['step', 'step'], show: [true, true, false] },
            'math_bitcrush': { labels: ['Bit Depth', 'Signal Floor'], types: ['step', 'linear'], show: [true, true, false] },
            'math_quant_rgb': { labels: ['Steps', ''], types: ['step', 'linear'], show: [true, false, false] },
            'math_quant_hsv': { labels: ['Steps', ''], types: ['step', 'linear'], show: [true, false, false] },
            'default': { show: [false, false, false] }
        };

        this.state = {
            width: 160,
            snapRes: true,
            contrast: 0,
            brightness: 0,
            saturation: 100,
            palette: 'auto16',
            ditherType1: 'bayer8', 
            ditherType2: 'jjn',    
            ditherMix: 50,         
            ditherAmt: 50,         
            exportScale: 1,        
            zoom: 1, panX: 0, panY: 0,
            zoomSnap: true,
            axis1: 8, axis2: 50, axis3: 8,
            useRedmean: true,
            // New Tool State
            activeTool: 'move' // 'move', 'hand', 'pick'
        };

        this.processedData = null;
        this.isProcessing = false;

        this.initListeners();
        this.initDefaultImage();
        this.updateToolUI();
    }

    /**
     * Calculates the step value from a slider position (exponential curve).
     * @param {number} val - Slider value (0-100).
     * @returns {number} The calculated step value (2-256).
     */
    getStepFromSlider(val) { if(val<=0) return 2; return Math.round(2 + 254 * Math.pow(val / 100, 3)); }

    /**
     * Calculates the slider position from a step value (inverse exponential).
     * @param {number} val - Step value (2-256).
     * @returns {number} The calculated slider value (0-100).
     */
    getSliderFromStep(val) { if(val<=2) return 0; return Math.pow((val - 2) / 254, 1/3) * 100; }

    /**
     * Converts a slider value (0-100) to a linear byte value (0-255).
     * @param {number} val - Slider value.
     * @returns {number} Byte value (0-255).
     */
    getLinearFromSlider(val) { return Math.round((val / 100) * 255); }

    /**
     * Converts a linear byte value (0-255) to a slider value (0-100).
     * @param {number} val - Byte value.
     * @returns {number} Slider value.
     */
    getSliderFromLinear(val) { return (val / 255) * 100; }

    /**
     * Updates the axis values in the state based on slider or number input.
     * Handles synchronization between slider and number box.
     * @param {string} idx - The axis index ('1', '2', or '3').
     * @param {string} source - The source of change ('slider' or 'number').
     */
    updateAxisValue(idx, source) {
        const slider = this.ui.els[`inpAxis${idx}`];
        const number = this.ui.els[`numAxis${idx}`];
        const config = this.PALETTE_CONFIG[this.state.palette] || this.PALETTE_CONFIG['default'];
        const type = config.types ? config.types[idx-1] : 'step';
        let finalVal;
        
        if (source === 'slider') {
            const sVal = parseFloat(slider.value);
            finalVal = (type === 'step') ? this.getStepFromSlider(sVal) : this.getLinearFromSlider(sVal);
            number.value = finalVal;
        } else {
            let nVal = parseInt(number.value) || 0;
            if(type === 'step') { nVal = Math.max(2, Math.min(256, nVal)); slider.value = this.getSliderFromStep(nVal); } 
            else { nVal = Math.max(0, Math.min(255, nVal)); slider.value = this.getSliderFromLinear(nVal); }
            finalVal = nVal; number.value = finalVal; 
        }
        this.state[`axis${idx}`] = finalVal;
        this.debounceProcess();
    }

    /**
     * Updates the UI state (visibility of axes) based on selected palette mode.
     */
    updateUIState() {
        const config = this.PALETTE_CONFIG[this.state.palette] || this.PALETTE_CONFIG['default'];
        const show = config.show || [false, false, false];
        ['1','2','3'].forEach((idx, i) => {
            const wrap = this.ui.els[`wrapAxis${idx}`];
            if (show[i]) {
                wrap.classList.remove('hidden');
                this.ui.els[`lblAxis${idx}`].innerText = config.labels[i];
                const val = this.state[`axis${idx}`];
                const type = config.types[i];
                this.ui.els[`numAxis${idx}`].value = val;
                this.ui.els[`inpAxis${idx}`].value = (type === 'step') ? this.getSliderFromStep(val) : this.getSliderFromLinear(val);
            } else { wrap.classList.add('hidden'); }
        });
    }

    updateToolUI() {
        const { toolMove, toolHand, toolPick } = this.ui.els;
        [toolMove, toolHand, toolPick].forEach(b => b.classList.remove('active'));
        if(this.state.activeTool === 'move') toolMove.classList.add('active');
        if(this.state.activeTool === 'hand') toolHand.classList.add('active');
        if(this.state.activeTool === 'pick') toolPick.classList.add('active');

        // Cursor
        const vp = this.ui.els.viewport;
        if(this.state.activeTool === 'hand') vp.style.cursor = 'grab';
        else if(this.state.activeTool === 'pick') vp.style.cursor = 'crosshair';
        else vp.style.cursor = 'default';
    }

    updateLayerUI() {
        const list = this.ui.els.layerList;
        list.innerHTML = '';
        const layers = [...this.layerManager.layers].reverse(); // UI shows top first

        layers.forEach(l => {
            const el = document.createElement('div');
            el.className = 'layer-item';
            if(l.id === this.layerManager.activeLayerId) el.classList.add('active');

            // Visibility
            const vis = document.createElement('div');
            vis.className = 'layer-vis';
            vis.innerText = l.visible ? '👁' : '·';
            vis.onclick = (e) => { e.stopPropagation(); this.layerManager.toggleVis(l.id); };

            // Thumbnail (tiny canvas)
            const thumb = document.createElement('canvas');
            thumb.className = 'layer-thumb';
            thumb.width = 24; thumb.height = 24;
            const tCtx = thumb.getContext('2d');
            tCtx.drawImage(l.img, 0, 0, 24, 24);

            const name = document.createElement('span');
            name.innerText = l.name;
            name.className = "text-xs truncate flex-1 font-bold";

            el.appendChild(vis);
            el.appendChild(thumb);
            el.appendChild(name);
            el.onclick = () => { this.layerManager.setActive(l.id); this.updateMaskUI(); };
            list.appendChild(el);
        });

        this.updateMaskUI();
    }

    updateMaskUI() {
        const l = this.layerManager.getActive();
        const g = this.ui.els.groupMasking;
        if (!l) {
            // Disable or dim?
            return;
        }

        // Sync controls with active layer
        this.ui.els.chkMask.checked = l.mask.enabled;
        this.ui.els.inpMaskHex.value = l.getMaskHex();
        this.ui.els.maskColorPreview.style.backgroundColor = l.getMaskHex();
        this.ui.els.inpMaskThresh.value = l.mask.threshold;
        this.ui.els.valMaskThresh.value = l.mask.threshold;
        this.ui.els.inpMaskSoft.value = l.mask.softness;
        this.ui.els.valMaskSoft.value = l.mask.softness;
    }

    /**
     * Initializes the default startup image.
     */
    initDefaultImage() {
        const img = new Image();
        img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAAAAAA6fptVAAAACklEQVR4nGNiAAAABgADNjd8qAAAAABJRU5ErkJggg==";
        
        const defaultImg = new Image();
        defaultImg.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAABlBMVEUAAAAAAAClZ7nPAAAAAXRSTlMAQObYZgAAAFRJREFUeNrtwQENAAAAwqD3T20PBxQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODLABtAAAE41535AAAAAElFTkSuQmCC";
        defaultImg.onload = () => {
            const cvs = document.createElement('canvas');
            cvs.width = 400; cvs.height = 300;
            const ctx = cvs.getContext('2d');
            const grd = ctx.createLinearGradient(0,0,400,300);
            grd.addColorStop(0, "#ff0080");
            grd.addColorStop(0.5, "#8000ff");
            grd.addColorStop(1, "#00ffff");
            ctx.fillStyle = grd;
            ctx.fillRect(0,0,400,300);
            ctx.fillStyle = "white";
            ctx.font = "bold 40px monospace";
            ctx.fillText("DROP IMAGE", 80, 150);
            const finalImg = new Image();
            finalImg.onload = () => {
                this.layerManager.addLayer(finalImg, "Background");
                this.triggerProcess();
            };
            finalImg.src = cvs.toDataURL();
        };
    }

    /**
     * Initializes all event listeners for UI controls.
     */
    initListeners() {
        // Universal Bind for Slider <-> Input synchronization
        const bind = (id, key) => {
            const slider = document.getElementById(id);
            const number = document.getElementById(id.replace('inp', 'val'));
            
            if(!slider) return;

            slider.addEventListener('input', (e) => {
                const v = parseInt(e.target.value);
                this.state[key] = v;
                if(number) number.value = v;
                this.debounceProcess();
            });

            if(number) {
                number.addEventListener('input', (e) => {
                    let v = parseInt(e.target.value);
                    if(isNaN(v)) return;
                    // Clamp
                    const min = parseInt(slider.min);
                    const max = parseInt(slider.max);
                    v = Math.max(min, Math.min(max, v));
                    
                    this.state[key] = v;
                    slider.value = v;
                    this.debounceProcess();
                });
            }
        };

        // Tools
        const setTool = (t) => { this.state.activeTool = t; this.updateToolUI(); };
        this.ui.els.toolMove.onclick = () => setTool('move');
        this.ui.els.toolHand.onclick = () => setTool('hand');
        this.ui.els.toolPick.onclick = () => setTool('pick');

        // Layer Controls
        this.ui.els.btnLayerUp.onclick = () => this.layerManager.moveOrder(1);
        this.ui.els.btnLayerDown.onclick = () => this.layerManager.moveOrder(-1);
        this.ui.els.btnLayerDel.onclick = () => this.layerManager.deleteActive();

        // Masking Controls
        const updateMask = () => {
             const l = this.layerManager.getActive();
             if(l) {
                 l.mask.enabled = this.ui.els.chkMask.checked;
                 l.mask.threshold = parseInt(this.ui.els.inpMaskThresh.value);
                 l.mask.softness = parseInt(this.ui.els.inpMaskSoft.value);
                 l.setMaskColor(this.ui.els.inpMaskHex.value);

                 // Sync inputs
                 this.ui.els.valMaskThresh.value = l.mask.threshold;
                 this.ui.els.valMaskSoft.value = l.mask.softness;
                 this.ui.els.maskColorPreview.style.backgroundColor = l.getMaskHex();

                 l.isDirty = true;
                 this.triggerProcess();
             }
        };
        this.ui.els.chkMask.addEventListener('change', updateMask);
        this.ui.els.inpMaskThresh.addEventListener('input', updateMask);
        this.ui.els.valMaskThresh.addEventListener('input', (e) => { this.ui.els.inpMaskThresh.value = e.target.value; updateMask(); });
        this.ui.els.inpMaskSoft.addEventListener('input', updateMask);
        this.ui.els.valMaskSoft.addEventListener('input', (e) => { this.ui.els.inpMaskSoft.value = e.target.value; updateMask(); });
        this.ui.els.inpMaskHex.addEventListener('change', updateMask);

        // Keyboard Shortcuts
        window.addEventListener('keydown', (e) => {
            if(e.target.tagName === 'INPUT') return;
            if(e.key.toLowerCase() === 'v') setTool('move');
            if(e.key.toLowerCase() === 'h' || e.key === ' ') setTool('hand');
            if(e.key.toLowerCase() === 'i') setTool('pick');
        });

        const { inpRes, valRes, chkSnap, menuBtnFile, dropdownFile, menuBtnPref, dropdownPref } = this.ui.els;

        // Menu Logic
        const closeMenus = () => {
            dropdownFile.classList.remove('show');
            dropdownPref.classList.remove('show');
        };
        menuBtnFile.addEventListener('click', (e) => { e.stopPropagation(); const o = dropdownFile.classList.contains('show'); closeMenus(); if(!o) dropdownFile.classList.add('show'); });
        menuBtnPref.addEventListener('click', (e) => { e.stopPropagation(); const o = dropdownPref.classList.contains('show'); closeMenus(); if(!o) dropdownPref.classList.add('show'); });
        document.addEventListener('click', closeMenus);

        // Paste support
        document.addEventListener('paste', (e) => {
            if (e.clipboardData && e.clipboardData.items) {
                for (let i = 0; i < e.clipboardData.items.length; i++) {
                    const item = e.clipboardData.items[i];
                    if (item.type.startsWith('image/')) {
                        e.preventDefault();
                        const file = item.getAsFile();
                        this.handleFile(file);
                        break;
                    }
                }
            }
        });

        this.ui.els.menuLoad.addEventListener('click', () => this.ui.els.fileInput.click());
        this.ui.els.menuSave.addEventListener('click', () => this.saveImage());
        
        // Zoom Snap Toggle
        this.ui.els.menuZoomSnap.addEventListener('click', (e) => {
            e.stopPropagation(); // Keep menu open? Or close. Let's close.
            this.state.zoomSnap = !this.state.zoomSnap;
            this.ui.els.checkZoomSnap.innerText = this.state.zoomSnap ? '✓' : '';
        });

        document.querySelectorAll('.scale-opt').forEach(el => {
            el.addEventListener('click', (e) => {
                const s = parseInt(el.dataset.scale);
                this.state.exportScale = s;
                document.querySelectorAll('[id^="check-scale-"]').forEach(c => c.innerText = '');
                document.getElementById(`check-scale-${s}`).innerText = '✓';
            });
        });

        // Resolution Special Case (Snap vs Text Input)
        inpRes.addEventListener('input', (e) => {
            let val = parseInt(e.target.value);
            this.state.width = val;
            valRes.value = val;
            this.debounceProcess();
        });

        valRes.addEventListener('input', (e) => {
             let val = parseInt(e.target.value);
             if(isNaN(val)) return;
             // Snap logic check? If typing manually, maybe don't force snap until blur?
             // For now direct mapping
             this.state.width = val;
             inpRes.value = val;
             this.debounceProcess();
        });
        
        chkSnap.addEventListener('change', (e) => {
            this.state.snapRes = e.target.checked;
            if(this.state.snapRes) {
                inpRes.step = "32";
                const val = parseInt(inpRes.value);
                const closest = Math.round(val / 32) * 32;
                inpRes.value = closest;
                valRes.value = closest;
                this.state.width = closest;
                this.debounceProcess();
            } else {
                inpRes.step = "2";
            }
        });

        bind('inpContrast', 'contrast');
        bind('inpBrightness', 'brightness');
        bind('inpSat', 'saturation');
        bind('inpDitherMix', 'ditherMix');
        bind('inpDitherAmt', 'ditherAmt');
        
        // Bind Selects
        const simpleBind = (id, key) => {
            const el = document.getElementById(id);
            el.addEventListener('change', (e) => {
                this.state[key] = e.target.value;
                this.debounceProcess();
            });
        };
        simpleBind('selDither', 'ditherType1');
        simpleBind('selDither2', 'ditherType2');

        this.ui.els.selPalette.addEventListener('change', (e) => {
            this.state.palette = e.target.value;
            this.updateUIState();
            this.debounceProcess();
        });

        document.getElementById('chkRedmean').addEventListener('change', (e) => {
            this.state.useRedmean = e.target.checked;
            this.debounceProcess();
        });

        ['1','2','3'].forEach(idx => {
            this.ui.els[`inpAxis${idx}`].addEventListener('input', () => this.updateAxisValue(idx, 'slider'));
            this.ui.els[`numAxis${idx}`].addEventListener('change', () => this.updateAxisValue(idx, 'number'));
        });
        
        this.ui.els.fileInput.addEventListener('change', (e) => this.handleFile(e.target.files[0]));

        const vp = this.ui.els.viewport;
        const overlay = this.ui.els.dragOverlay;
        vp.addEventListener('dragover', (e) => { e.preventDefault(); overlay.classList.remove('hidden'); });
        vp.addEventListener('dragleave', (e) => {
            e.preventDefault();
            if (e.relatedTarget && vp.contains(e.relatedTarget)) return;
            overlay.classList.add('hidden');
        });
        vp.addEventListener('drop', (e) => { e.preventDefault(); overlay.classList.add('hidden'); this.handleFile(e.dataTransfer.files[0]); });
        
        const btnCompare = this.ui.els.btnCompare;
        const showOriginal = () => { if(!this.originalSrc) return; this.ctx.drawImage(this.originalSrc, 0, 0, this.ui.els.mainCanvas.width, this.ui.els.mainCanvas.height); };
        const showProcessed = () => { if(!this.processedData) return; this.ctx.putImageData(this.processedData, 0, 0); };
        
        btnCompare.addEventListener('mousedown', showOriginal);
        btnCompare.addEventListener('mouseup', showProcessed);
        btnCompare.addEventListener('mouseleave', showProcessed);
        btnCompare.addEventListener('touchstart', (e) => { e.preventDefault(); showOriginal(); });
        btnCompare.addEventListener('touchend', (e) => { e.preventDefault(); showProcessed(); });

        this.setupViewportInteraction();
        this.updateUIState();
    }

    /**
     * Handles file input change (drag/drop or menu).
     * @param {File} file - The uploaded file.
     */
    handleFile(file) {
        if (!file || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                // Add as new layer
                const name = file.name || "Layer " + (this.layerManager.layers.length + 1);
                this.layerManager.addLayer(img, name);

                // If it's the first layer, reset view?
                if (this.layerManager.layers.length === 1) {
                    this.state.zoom = 1; this.state.panX = 0; this.state.panY = 0;
                    this.updateTransform();
                    this.updateZoomStatus();
                }
                this.triggerProcess();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    /**
     * Sets up mouse and touch interactions for the viewport (pan and zoom).
     */
    setupViewportInteraction() {
        const container = this.ui.els.viewport;
        const mainCanvas = this.ui.els.mainCanvas;
        let isDragging = false;
        let lastX, lastY;

        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (this.state.zoomSnap) {
                const direction = e.deltaY > 0 ? -1 : 1;
                let newZoom = Math.round(this.state.zoom + direction);
                newZoom = Math.max(1, newZoom);
                this.state.zoom = newZoom;
            } else {
                this.state.zoom *= (e.deltaY > 0 ? 0.9 : 1.1);
            }
            this.updateTransform();
            this.updateZoomStatus();
        });

        const startDrag = (cx, cy) => {
            if (this.state.activeTool === 'pick') {
                // Picking Logic
                const rect = mainCanvas.getBoundingClientRect();
                const x = (cx - rect.left) / (rect.width / mainCanvas.width);
                const y = (cy - rect.top) / (rect.height / mainCanvas.height);

                const scaleX = this.layerManager.width / mainCanvas.width;
                const scaleY = this.layerManager.height / mainCanvas.height;

                const fullX = x * scaleX;
                const fullY = y * scaleY;

                const l = this.layerManager.getActive();
                if (l) {
                    const lx = Math.floor(fullX - l.x);
                    const ly = Math.floor(fullY - l.y);

                    if (lx >= 0 && ly >= 0 && lx < l.img.width && ly < l.img.height) {
                         const tmp = document.createElement('canvas');
                         tmp.width = 1; tmp.height = 1;
                         const tctx = tmp.getContext('2d');
                         tctx.drawImage(l.img, -lx, -ly);
                         const p = tctx.getImageData(0,0,1,1).data;
                         const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1).toUpperCase();

                         this.ui.els.inpMaskHex.value = hex;
                         const event = new Event('change');
                         this.ui.els.inpMaskHex.dispatchEvent(event);
                    }
                }
                return;
            }
            isDragging = true;
            lastX = cx;
            lastY = cy;
        };

        const moveDrag = (cx, cy) => {
            if (!isDragging) return;
            // standard pan uses screen pixels
            const dx = cx - lastX;
            const dy = cy - lastY;
            lastX = cx;
            lastY = cy;

            if (this.state.activeTool === 'move') {
                // Moving layers requires scaling delta by zoom and process scale ratio
                // Canvas visual size vs composite size
                const processedW = this.state.width;
                const compositeW = this.layerManager.width;
                // Avoid division by zero
                if(processedW === 0 || this.state.zoom === 0) return;

                const ratio = compositeW / processedW;
                const z = this.state.zoom;

                this.layerManager.moveActive((dx / z) * ratio, (dy / z) * ratio);
            } else if (this.state.activeTool === 'hand') {
                this.state.panX += dx;
                this.state.panY += dy;
                this.updateTransform();
            }
        };

        container.addEventListener('mousedown', (e) => startDrag(e.clientX, e.clientY));
        window.addEventListener('mousemove', (e) => {
            if(!isDragging) return;
            moveDrag(e.clientX, e.clientY);
        });
        window.addEventListener('mouseup', () => isDragging = false);

        container.addEventListener('touchstart', (e) => { if(e.touches.length === 1) startDrag(e.touches[0].clientX, e.touches[0].clientY); });
        container.addEventListener('touchmove', (e) => {
            if(isDragging && e.touches.length === 1) {
                e.preventDefault();
                moveDrag(e.touches[0].clientX, e.touches[0].clientY);
            }
        });
        container.addEventListener('touchend', () => isDragging = false);
    }

    /**
     * Updates the CSS transform of the canvas based on zoom and pan state.
     */
    updateTransform() {
        this.ui.els.canvasWrapper.style.transform = `translate(${this.state.panX}px, ${this.state.panY}px) scale(${this.state.zoom})`;
    }
    
    /**
     * Updates the zoom percentage display in the status bar.
     */
    updateZoomStatus() {
        this.ui.els.statusZoom.innerText = `${Math.round(this.state.zoom * 100)}%`;
    }

    /**
     * Debounces the image processing to prevent excessive re-renders during slider dragging.
     */
    debounceProcess() {
        if (this.debounceTimer) clearTimeout(this.debounceTimer);
        this.debounceTimer = setTimeout(() => this.triggerProcess(), 200);
    }

    /**
     * Triggers the image processing pipeline with the current state.
     * Manages loading states and UI updates.
     */
    triggerProcess() {
        if (this.layerManager.layers.length === 0 || this.isProcessing) return;
        this.isProcessing = true;
        this.ui.els.loadingOverlay.classList.remove('hidden');
        
        // Get Composite
        const composite = this.layerManager.getComposite();
        this.processor.loadImage(composite);

        const options = {
            ...this.state,
            targetWidth: this.state.width,
            paletteId: this.state.palette
        };

        this.processor.process(options, () => {}, (imgData) => {
            this.processedData = imgData;
            this.ui.els.mainCanvas.width = imgData.width;
            this.ui.els.mainCanvas.height = imgData.height;
            this.ctx.putImageData(imgData, 0, 0);
            this.ui.els.statusMsg.innerText = "DONE.";
            this.ui.els.statusRes.innerText = `${imgData.width} x ${imgData.height}`;
            this.ui.els.loadingOverlay.classList.add('hidden');
            this.isProcessing = false;
        });
    }

    /**
     * Saves the processed image to the user's computer.
     * Upscales the image if an export scale factor is set.
     */
    saveImage() {
        if(!this.processedData) return;
        const exportCvs = document.createElement('canvas');
        const w = this.processedData.width, h = this.processedData.height, s = this.state.exportScale;
        exportCvs.width = w * s; exportCvs.height = h * s;
        const ctx = exportCvs.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        const tmp = document.createElement('canvas');
        tmp.width = w; tmp.height = h;
        tmp.getContext('2d').putImageData(this.processedData, 0, 0);
        ctx.drawImage(tmp, 0, 0, w * s, h * s);
        const link = document.createElement('a');
        link.download = `retro_lab_${Date.now()}.png`;
        link.href = exportCvs.toDataURL();
        link.click();
    }
}

window.onload = () => new App();
</script>
</body>
</html>